---
title: Redis（一）概述
date: 2020-12-15 14:59:00
tags: [Redis,理论知识]
categories: [中间件,Redis,Nosql]
keywords: Java
description: redis的基本概念和简单理论知识
top_img:
comments: true
cover: https://i.loli.net/2020/12/15/AFq8SCP2jefbHKa.png
toc:
toc_number:
auto_open:
copyright:
mathjax:
katex:
aplayer:
highlight_shrink:
top: false
---
# Redis
## 一、什么是Redis
> Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助

redis 是c语言开发的一个开源的高性能简直对（key-value）的内存数据库，可以用同作数据库、缓存、消息中间件等。他是一种NoSql(not-only sql,泛之非关系型数据库)的数据库

## 二、Redis有哪些特点
1. 性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS。
2. 单进程单线程，是线程安全的，采用 IO 多路复用机制。
3. 丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。
4. 支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载。
5. 主从复制，哨兵，高可用。可以用作分布式锁。可以作为消息中间件使用，支持发布订阅。

## 三、Redis支持的五种数据类型

+ string(字符串)
+ hash(散列表)
+ list(列表)
+ set(集合)
+ z-set(有序集合)

![redistObject](https://i.loli.net/2020/12/15/poqLKbetAuUCkYz.png)

![encoding](https://i.loli.net/2020/12/15/8N52qAZJ49h6pXP.png)

### 1.String字符串

String是Redis最基本的数据类型，它数据结构存储方式有三种int、raw、embstr，它不仅可以存储字符串，还可以存储整数、浮点数、甚至是二进制数据，比如jpg图片或序列化的对象（一个String最大存储**512M**)，String 类型是二进制安全的。

### 2.hash散列表

![hash](https://i.loli.net/2020/12/15/GrCuH2vKhaZyoWd.png)

Hash（哈希）类型是从redis-2.0版本之后才有的数据结构，用于存放字符串和字符串之间的映射。Hash对象的实现方式有两种，分别是 Ziplist 和 hashtable，其中 hashtable 的存储方式 Key 是 String 类型， value 也是以 key-value 的形式进行存储。has适合存储对象。

`常用命令`：hget，hset，hgetall 等。

### 3.list列表

List 类型是一种链表结构，主要功能是 push （进栈）、pop（出栈）；List 类型在 redis-3.2 之前的版本是使用 ziplist 和 linkedlist 进行实现的，之后版本就是引入 quicklist

`应用场景`：List 应用场景非常多，也是 Redis 最重要的数据结构之一，比如 Twitter 的关注列表，粉丝列表都可以用 List 结构来实现。

`常用命令`：lpush、rpush、lpop、rpop、lrange（获取列表片段）等。



### 4.set集合

Set 类型是 String 类型的无序集合，Set 集合是不可重复的，而 List 列表可以存储相同的字符串

`应用场景`：Redis Set 对外提供的功能和 List 一样是一个列表，特殊之处在于 Set 是自动去重的，而且 Set 提供了判断某个成员是否在一个 Set 集合中。

`实现方式`：Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。

`常用命令`：sdd、spop、smembers、sunion 等

### 5.zset有序集合

Zset 类型是 String 类型的有序集合，Zset 集合是不可重复的，它的底层实现是 ziplist 和 skiplist（跳跃表）

`使用场景`：Sorted Set 可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。

`实现方式`：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。

`常用命令`：zadd、zrange、zrem、zcard 等。

### 总结
类型|**简介**|**特性**|**场景**|**大小**
:---|:---|:---|:---|:---
**string**|二进制安全|可以包含任何数据，例如jpg图片或序列化对象|-|最大512m
**hash**|健值对集合，map|适合存储对象|存储、读取、修改用户属性|-
**List**|双向链表|增删快，提供了操作某一元素的api|消息通知、消息队列|-
**set**|hash表实现元素不重复|增、删、查的复杂度都是O(1),提供了交集、并集、差集的操作|共同好友|-
**zset**|set元素增加一个权重score，按权重排序|数据插入时就做好了排序|排行榜，带权重的消息队列|-

## 四、如何使用Redis
`结合Springboot`
1.  RedisTemplate
2.  Spring Cache
**该部分内容待展开**

## 五、Redis为什么这么快
> 官方提供的数据可以达到 100000+ 的 QPS

+ 大家都在用肯定很快
+ 单线程
    Redis 是单进程单线程的模型，因为 Redis 完全是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。

    1. Redis 完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度是 O(1).
    2. 数据结构简单，对数据操作也简单.
    3. 采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的 CPU 切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。
    4. 使用多路复用 IO 模型，非阻塞 IO。

## 六、为什么选用redis而不是memcached

比较方面|**redis**|**memcached**
:---|:---|:---
**存储方式**|Redis 有部分数据存在硬盘上，这样能保证数据的持久性|会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小
**数据类型支持**|支持五种数据类型|对数据类型的支持简单，只支持简单的 key-value
**底层模型**|直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求|-
**value大小**|max 1GB| max 1MB

## 七、淘汰策略
策略|描述
:---|:---
volitile-lru|从已设置过期时间的kv集中，优先对近期最少使用的淘汰（less recently used）
volitile-ttl|从已设置过期时间的kv集中，优先对剩余时间短的淘汰（time to live）
volitile-random|从已设置过期时间的kv集中，随机淘汰
volitile-lfu| 从已设置过期时间的kv集中，讲访问频率最小的淘汰（least frequency use）
allkeys-lru|从所有kv集中，优先对近期最少使用的淘汰（less recently used）
allkey-random|从所有kv集中，随机淘汰
allkeys-lfu|从所有kv集中，讲访问频率最小的淘汰（least frequency use）
noeviction|不淘汰策略，若超过最大内存则反悔错误信息

## 八、持久化

> Redis 为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。

当 Redis 重启的时候，它会优先使用 AOF 文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存。

### 持久化策略

#### 1.RDB

`RDB`：RDB快照形式是直接把内存中的数据保存到一个 dump 的文件中，定时保存，保存策略。Redis 默认是快照 RDB 的持久化方式。

`工作方式`： 默认 Redis 是会以快照"RDB"的形式将数据持久化到磁盘的一个二进制文件 dump.rdb。

`工作原理`： 当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到磁盘上一个临时 RDB 文件中。

`优点`：这种文件非常适合用于备份：比如，你可以在最近的 24 小时内，每小时备份一次，并且在每个月的每一天也备份一个 RDB 文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适合灾难恢复。

`缺点`：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。

当子进程完成写临时文件后，将原来的 RDB 替换掉，这样的好处是可以 copy-on-write。

#### 2.AOF

AOF：把所有的对 Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。

使用 AOF 做持久化，每一个写命令都通过 write 函数追加到 appendonly.aof 中，配置方式如下：

appendfsyncyesappendfsync always #每次有数据修改发生时都会写入AOF文件。appendfsync everysec #每秒钟同步一次，该策略为AOF的缺省策略。

AOF 可以做到全程持久化，只需要在配置中开启 appendonly yes。这样 Redis 每执行一个修改数据的命令，都会把它添加到 AOF 文件中，当 Redis 重启时，将会读取 AOF 文件进行重放，恢复到 Redis 关闭前的最后时刻。

`优点`： 会让 Redis 变得非常耐久。可以设置不同的 Fsync 策略，AOF的默认策略是每秒钟 Fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。

`缺点`：对于相同的数据集来说，AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 Fsync 策略，AOF 的速度可能会慢于 RDB。


#### 3. 使用哪种策略

如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用 RDB 持久。
AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能。
数据库备份和灾难恢复：定时生成 RDB 快照非常便于进行数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度快。
当然了，Redis 支持同时开启 RDB 和 AOF，系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。

## 九、Redis使用过程中会遇到那些问题

### 1.缓存与数据库一致性问题

分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。
我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。
合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。

### 2.缓存穿透和缓存击穿

#### 2.1缓存穿透

穿透是指缓存和数据库中没有的数据，用户高并发量的请求，造成的大量请求直接访问数据库
![穿透](https://i.loli.net/2020/12/16/8mTedRQgC1PxF3k.png)

`原因`： 
1. 代码或业务本身存在问题或漏洞
2. 恶意攻击造成大量空的命中

`解决方案`：
1. 设置布隆过滤器，
将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

2. 如果一个查询返回的数据为空，不管是数据不存在还是系统故障，我们仍然把这个结果进行缓存，并且设置一个较短的过期时间。

#### 2.2 缓存击穿

缓存击穿，就是说**某个 key 非常热点**，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库。

![击穿](https://i.loli.net/2020/12/16/CTLlBYj5k6rKwSg.png)

`解决方案`

- 解决方式也很简单，可以将热点数据设置为永远不过期；
- 基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据


### 3.Reids雪崩

缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，大量数据会去直接访问DB，此时给DB很大的压力
![雪崩](https://i.loli.net/2020/12/16/XEl3i8KH7xoUTMk.png)

`解决方案`

1. 设置redis集群和DB集群的高可用，如果redis出现宕机情况，可以立即由别的机器顶替上来。这样可以防止一部分的风险。

2. 使用互斥锁
在缓存失效后，通过加锁或者队列来控制读和写数据库的线程数量。比如：对某个key只允许一个线程查询数据和写缓存，其他线程等待。单机的话，可以使用synchronized或者lock来解决，如果是分布式环境，可以是用redis的setnx命令来解决。

3. 不同的key,可以设置不同的过期时间，让缓存失效的时间点不一致，尽量达到平均分布。

4. 永远不过期
redis中设置永久不过期，这样就保证了，不会出现热点问题，也就是物理上不过期。

5. 资源保护
使用netflix的hystrix，可以做各种资源的线程池隔离，从而保护主线程池。


### 4.穿透、击穿和雪崩的区别

如果把redis缓存服务比做一张网横在客户端和DB之间，
**穿透**可以看作是请求从网的网眼里钻过去没有兜住，
**击穿**可以看作是很多请求在一个地方把网给戳破了，
那么**雪崩**就是因为这张网没有起到作用或者没有网导致大量请求直接访问DB，从而导致服务瘫痪和依赖他的服务阻塞或瘫痪而产生一些列崩溃

## 十、如何保证Redis的高可用
**该部分内容待展开**
### 主从
### 哨兵










